## 2주차 - 모니터링과 트랜잭션
### 예외란?
- 프로그램의 정상적인 실행을 방해하는 비정상적인 상황
- 예상하지 못한 예외적인 상황
- 개발자가 절대 피할 수 없는것, 처리가 가능함

겪어본 대표적인 장애가 뭐가있을까? -> 카카오톡 IDC 화재사건.. <br>

### 서비스 장애
장애? 사용자가 불편함을 체감할 수 있는 상황 (설정한 기준을 초과한 상황) <br>
-> 응답시간 기준을 초과하여 발생한 응답 -> 장애 <br>

장애가 자주 발생한다면? 사용자 부정적인 서비스 경험을 가진다 -> 재방문 X, 사용자 이탈 의 결과를 초래한다 <br>

장애를 방지하기 위해서는 어떻게 해야할까? 바로 모니터링을 통해 예방 및 대처를 할 수 있다 <br>

### 모니터링
🖐🏽서비를 지속적으로 관찰하고 서비의 상태를 감시(=확인) 하여 장애 발생을 미연에 방지하기 위함이다 <br>
이슈들이 발생할 수 있는 것, 지표를 체크해야 한다.

그럼 모니터링은 언제 하나?
- 응답이 늦다
- CPU 사용 급등, 메모리 부족
  - 로직 내부에서 CPU 자원을 너무 많이 사용, 메모리를 너무 많이 사용

<br>
모니터링을 할 때 어떤 지표를 봐야하나? <br>
- cpu, 네트워크 I/O , 

만약 장애를 초래한 원인을 제대로 분석하지 않는다면 ? <br>
- cpu 부족 -> 코어 올리기
- 메모리 부족 -> 메모리 업그레이드
- micro -> large


위 장애를 손 쉽게 처리하는 방법은 사실 자원을 증설하는것이 제일 쉽다. 하지만 비용적으로 부담이 많이 될 것이다 <br>
-> 동일한 증상이 반복된다? 계속 업그레이드하면 비용만 계속 올라간다 <br>

즉 서버의 자원을 최적화를 통한 비용 최적화를 해야하며, 최후의 보루로 서버 자원 업그레이드를 생각하는게 좋다 <br>
서비스 장애 방지를 하는 것이 비용 최적화에도 도움이 된다 <br><br>

그럼 모니터링은 누가 해야될까?
1) 개발자
2) 대표님
3) 기획자

셋다 하는게 좋고, 모니터링을 통한 장애 방지 및 해결은 개발자 및 인프라팀에서 하는것이 맞다  <br> 

그리고 24시간 모니터링을 할 수는 없다 <br>
그러므로 모니터링 지표에 대한 알림 서비스를 도입하여 불필요한 인력 소모를 줄일 필요가 있다 <br>

모니터링 도구를 사용해서 사람을 대신한다 <br>
- 서비스 위험 기준을 정의
- 서비스 장애 기준을 정의
- 서비스 장애 알림 절차 정의(적절한 대상에 적절하게 공지)


우리 서비스는 작은대 모니터링이 필요할까? <br>
- 서버 리소스 관리
- 안정적인 서비스
- 성능 최적화

위 모니터링을 통해 사용자들에게 안정적인 서비스와 신뢰감을 제공할 수 있으며 내부 비용 또한 최적화 할 수 있다 <br>

보통 어플리케이션은 (개발 -> 배포 -> 운영 -> 사용자 실사용) 을 흐름을 가질 것이다 <br> 

서비스 과정에서 장애/예외가 발생한다면? 만약 모니터링을 하지 않는다면? <br>
어떤 상황인지 어떻게 파악을 할 수 있을까? <br>

- 개발자가 항상 서비스를 사용하며 에러를 찾는다?
- 에러가 발생한 사용자로부터 제보
- 그냥 에러 안나길 기도한다?

위 3가지 요소로 장애를 파악한다면 시간,비용,인력 낭비가 될 것이다 <br>

그리고 위 장애가 반복된다면 사용자는 우리 서비스를 이탈하게 될 것이다 <br> 

위 장애를 반복하지 않기 위해서는 당연하게
- 언제 장애가 발생하나?
- 왜 에러가 발생하나?
- 어디에서 발생하나?

위 3가지 질문을 던져보며 차근차근 해결할 필요가 있다 <br>


## 로그
> 시스템, 어플리케이션에서 동작과 오류등에 대한 기록 데이터

로그를 남기는 시점과 어떻게 로그를 남길 것인지에 대한 고민을 해보자 <br>

- 서비스의 중요한 영역 모든 곳에 로그를 남기는 것이 좋다
- 예외처리를 한 지점에 로그 남기기

로그 포맷 -> 로그 레벨, 타임 스탬프, 요청자 정보, 요청된 자원 정보, 응답 상태 등<br>
민감한 정보, 사용자 개인정보 위치 저장 등은 저장 X <br>

로깅 레벨 : 로그 메시지의 중요도를 나타내는 단계 <br>
- DEBUG : 개발과정에서 문제를 찾을 떄
- INFO : 일반적인 정보 기록
- WARN : 잠재적인 문제
- ERROR : 심각한 문제 발생
- FATAL : 매우 심각한 문제

보통 로깅 DEBUG 레벨은 운영에서는 사용하지 않고 로컬(=개발 서버) 에서 자세한 기록을 확인하는 용도로 사용 <br>


## 트랜잭션
> 데이터베이스에서 수행되는 작업들이 하나의 논리적 단위로 묶인 것

트랜잭션의 기본 흐름 
- start transaction : 트랜잭션 시작
- write, read : 연산 수행
- commit : 데이터베이스 저장
- rollback : 문제가 생긴경우 되돌림
- autocommit : 자동 저장


트랜잭션의 4가지 특징
- 원자성 : 모두 성공하거나 실행되지 않아야 한다.
- 일관성 : 트랜잭션이 시작되고 종료된 경우에도 일관된 상태를 유지해야 한다.
- 독립성 : 트랜잭션은 서로 영향을 끼쳐서는 안된다.
  - 격리수준 -> 동시성 제어
  - Dirty-Read : 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있는 상태
  - Non Repeatable read : 동일한 조회에 대해 값이 달라짐
  - Phantom read : 없던 데이터가 생겨남

위 문제를 해결하기 위해서 격리수준을 두어서 관리를 해야 한다 <br>
- read uncommited : dirty_dead, non_repetable read, phantom read
- read commited : non_repetable read, phantom read
- repeatable read : phantom_read
- serializable -> 데이터베이스의 성능 저하

#### 동시성 제어
- 공유락 : 서로 다른 트랜잭션이 같은 데이터를 읽을 수 있도록 함
- 배타적 락 : 서로 다른 트랜잭션이 같은 데이터를 읽거나 쓰기를 할 수 없게 함
- 2PL 프로토콜 : 트랜잭션에 필요한 모든 락을 먼저 획득하고 해제함 -> 데드락이 발생 할 수 있음 

- 지속성 : 트랜잭션이 종료되고 저장되었다면, 영구적으로 상태가 지속되어야 한다.